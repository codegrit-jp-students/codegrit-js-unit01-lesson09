# Lesson 9. 関数(Function)

## 目的

- 関数の概念を理解する。
- 自分で関数を定義できるようになる。

## 関数とは

**_関数_**は再利用が可能なコードの塊です。英語名を使って**ファンクション**とも呼ばれることもあります。**_関数_**はプログラミングの主役と言っても良いほどに頻繁に使われています。以下が関数の基本的なシンタックスです。

```js
function myFunc() {
  //関数の処理文
}

// 関数の呼び出し
myFunc();
```

関数はブロック「{}」で囲まれた構造を持ちます。このブロックの中に処理を書いておき、`myFunc();`の一行でこの関数を呼び出すだけで関数のコードを実行することができます。同じコードを何度も記述するような手間が省け、また関数をうまく使うことでプログラムの可読性、メンテナンス性を高めることができます。


上記のような構文を使って関数を定義することを**_関数宣言(function文)_**と言います。
`myFunc`と書かれた部分がこの関数の名前になります。冒頭の`function`はこれが関数であることを明示するための**予約語**なので必ず記述しなければなりません。
関数名は任意ですがその機能に合わせた適切な名前にすると良いでしょう。また以下のようなルールがあるので覚えておきましょう。

- JavaScriptの予約語は使うことができません。(例. `if`、`for`、`var`、`let`、`const`など)
- 関数を定義したスコープ上に同じ関数名や変数名がある場合、重複して使うことはできません。
- 大文字と小文字は区別されます。(**ケースセンシティブ**といいます)
- 名前の1文字目で使えるのは半角の英字、ドル記号、アンダースコアのみ。2文字目以降はこれに加えて半角数字を使用可能です。
- Unicodeが認められているので、日本語文字も関数名として使うことができます。(非推奨)

## 関数宣言の構文

プログラミング言語では関数を使うことを**関数を呼び出す**と表現します。関数を呼び出すには、利用したい箇所で次のように`関数名();`と記述します。

```js
myFunc();
```
次の簡単な例ではメッセージをログとして出力する処理を記述した関数を呼び出しています。

```js
function displayMessage() {
  console.log('Message');
}

// 関数の呼び出し
displayMessage(); // 'Message'
```

この例のように処理が一行しかない場合は、わざわざ関数にして呼び出す意味がないように思えます。しかし処理内容が複雑になるにつれ関数は威力を発揮するようになります。

## 戻り値を持つ関数

関数は呼び出すだけではなく、何らかのデータを結果として返すこともできます。
この返されたデータは**_戻り値_**といいます。
次の例では、関数の中で宣言した変数に3を掛けた計算結果を戻り値として取得しています。

```js
function multiplyNum() {
  let number = 5;
  return number * 3; // 関数の結果を返す記述
}

// 関数の呼び出し
console.log(multiplyNum()); // 15
```

この例のように関数を使った出力結果が欲しい場合は、その戻り値を`return 戻り値;`のように記述しておきます。この`return`を使った文は関数処理の最後に記述しておく必要があります。上記の例では関数の呼び出しを`console.log()`の中で実行すると、出力結果である戻り値がそのまま`console.log`へ格納されるようになります。`return`を使った関数の一回の呼び出しで返すことができるのは一つの値のみです。複数の値を一度に返すことはできません。

また関数はブロックの中に**スコープ(関数スコープ)**を持ちます。従って関数の中で宣言された値に外部から直接アクセスすることはできません。

```js
function multiplyNum() {
  let number = 5; // 関数外部から直接アクセスはできない
  return number * 3;
}
console.log(number); // 出力結果は「undefinded」になる。
```
それでは例えば、関数の中で宣言した変数の値を別の値に変更したい場合はどうすれば良いのでしょうか。これは次で述べる**_引数_**を使うことで実現できます。

## 関数の引数

関数は、**_引数_**を利用することで呼び出し時に値を渡すことができます。N個の**_引数_**を持つ関数は次のように定義できます。

```js
function funcName(引数1, 引数2 , ..., 引数N) {
  // 関数の処理文
}
```

関数を呼び出す際は次のようにして**_引数_**を渡すことができます。

```js
funcName(引数1, 引数2 ,...,引数N); // 関数呼び出し
```

関数呼び出し時の引数は**_実引数_**と呼ばれ、関数定義で値が渡される側の引数のことを**_仮引数_**と呼びます。**_実引数_**は記述された順番で仮引数に格納されていきます。**_仮引数_**は**関数スコープ**を持ち、関数ブロック内で変数として利用することができます。

具体例で確認しましょう。次の例では、関数の呼び出し時に2つの数値を渡して、関数は渡された2つの値の和を求めてその結果を返すという処理を行なっています。

```js
function addNumber(num1, num2) {
  let sum = num1 + num2; // ２つの値の和を格納する変数
  return sum;
}

console.log(addNumber(4,5)); // 9
```

この例ではまず、関数呼び出す際に関数に渡したい値を`addNumber(4,5)`のように記述します。この時実引数4は仮引数`num1`へ格納され、実引数5は仮引数`num2`へと格納されます。

## 初期値を持つ仮引数

ES6では仮引数に初期値を与えることができます。

```js
function addNumber(num1, num2 = 1) {
  let sum = num1 + num2; // num2は1
  return sum;
}

console.log(addNumber(4)); // 5
```
上記の場合、実引数の4は仮引数で定義された順番で格納されていくので、`num1`に格納されます。この時、本来であれば仮引数に対して実引数が一つ足りないのでエラーが起きそうな気がしますがそうはなりません。もし引数が与えられなかったとしても`num2 = 1`とあるように、デフォルトで初期値1が与えられた状態で処理が実行できます。もちろんこれは初期値なので、実引数を与えれば上書きされます。

```js
function addNumber(num1, num2 = 1) {
  let sum = num1 + num2; // num2は6
  return sum;
}

console.log(addNumber(4, 6)); // 10
```
## arguments
JavaScriptでは、関数に任意の個数渡された引数は内部で自動的に`arguments`という名前の**配列**として格納されるので、関数内でこれを取り扱うことができます。

```js
let func = function() {
  for(let i = 0; i < arguments.length; ++i) {
    console.log(arguments[i]);
  }
};

func('a','b','c','d','e');
```

出力結果：
```
'a'
'b'
'c'
'd'
'e'
```

## 残余引数(Rest Parameters)

関数定義に記述する最後尾の引数に 「...」の接頭辞を付与すると、この引数は呼び出し側の**残りの実引数全てを 要素にもつ配列**になります。この時配列となった引数のことを**_残余引数(Rest Parameters)_**と呼びます。仮引数がひとつしか定義されていない場合はそれ自身が**_残余引数_**になります。

```js
function sample(...args) {
  console.log(args.length);
}

sample(); // 引数を与えない
sample(100); // 引数を1つ
sample(100, 200, 300); // 引数を3つ
```

出力結果:
```
0
1
3
```

この時の`args`は配列なので、通常の配列と同じように要素数を返す**lengthプロパティ**を使うことができているのがわかります。

次の例のように引数が複数ある場合は、すでに説明した通り残りの実引数が各要素となって配列に格納されます。

```js
function sample(a, b, c, d, ...args) {
  // 繰り返し処理で配列の中の要素を取り出す
  for (let i = 0; i < args.length; i++) {
    console.log(args[i]);
  }
}

sample(1,2,3,4,5,6,7,8,9); // 5〜9までが配列になる
```

出力結果:
```js
5
6
7
8
9
```

## 関数式
ここまでは関数宣言として関数を単体で定義する記述について見てきましたが、ここでは別の関数の定義の仕方を説明します。

## 関数式の構文

次のように宣言された変数に格納するような形で関数を定義する式を**_関数式(function演算子)_**と呼びます。

```js
let func = function function_name(引数1,引数2 ,...,引数N) {
// 関数の処理文
}
```

ここでは関数名をあえて指定していますがこれは省略することができます。実際には次に説明する関数名を省略した無名関数を使うことが一般的です。

## 無名関数の構文

```js
let func = function(引数1,引数2 ,...,引数N) {
// 関数の処理文
}
```

関数は関数名をつけずに定義することができます。この関数のことを**_無名関数_**あるいは**_匿名関数_**と言います。
関数式で定義した関数を呼び出す際は関数式で宣言された変数を使います。

```js
let func = function() { return 'Message!'; }
console.log(func()); // 'Message!'
```
**_無名関数_**も関数宣言された関数と同じように引数を使って入出力が実装できます。

```js
function displayLog() {
  total = func(2, 5, 8); // 無名関数に引数を格納して実行
  console.log(`The total number is ${total}`);
}

let func = function(x, y, z) {
  return x + y + z;
}

displayLog(); // 'The total number is 15'
```

## 関数コンストラクタ

関数宣言、関数式の他にもうひとつ**_関数コンストラクタ_**という方法を使って関数を定義することができます。


## 関数コンストラクタの構文

**_関数コンストラクタ_**は本来オブジェクトを生成する方法です。**_関数コンストラクタ_**はオブジェクトを生成する際使われる宣言キーワード`new`を使って生成することができます。
この`new`を伴って**_コンストラクタ関数_**を呼び出すことで特別な役割を果たすことが出来ます。
**_関数コンストラクタ_**ではFunctionクラスのオブジェクトが生成できます。

```js
let 変数名 = new Function('引数1', '引数2', ..., '引数N', '処理文');
```

Functionに続く括弧「()」の中に引数を記述していきます。ただし、最後尾は引数ではなく関数の処理文を記述します。引数および処理文はダブルクオーテーションで囲みます。
以下は**_関数コンストラクタ_**を使ったサンプルコードです。

```js
function displayLog()
{
  total = func(2, 5, 8); // 関数コンストラクタに引数を格納して実行
  console.log('The total number is '+total);
}
let func = new Function(
  'x',
  'y',
  'z',
  'return x + y + z;'
);

displayLog(); // 'The total number is 15'
```

# 関数宣言と関数式と関数コントラクタの違い
以下の3種類の関数はそれぞれ同じ結果を出力します。

```js
// 関数宣言
function func1(a, b) {
  return a*b;
}
// 関数式
let func2 = function(a, b) {
  return a*b;
}
// 関数コントラクタ
let func3 = new Function('a', 'b', 'return a * b;');

console.log(func1(4,8)); // 32
console.log(func2(4,8)); // 32
console.log(func3(4,8)); // 32
```

ただし関数式と**_関数コンストラクタ_**で定義されたものとは違い、関数宣言で定義された関数は定義式より前で呼び出すことができます。
```js
// 関数宣言
message(); // 'Hello!'
function message() {
   console.log('Hello');
}
```
```js
// 関数式
message(); // TypeErrorとなり出力されない
var message = function(){
   console.log('Hello');
}
```
```js
// 関数コントラクタ
message(); // TypeErrorとなり出力されない
var message = new Function(console.log('Hello'));
```

# アロー関数
ES6から新しい関数の定義方法として、**_アロー関数_**が追加されました。**_アロー関数_**を定義するときは次のように**矢印記号「=>」+**を使って関数を定義するのが特徴です。
**_アロー関数_**の基本的な書き方は以下のようになります。

```js
// アロー関数の宣言の基本構文
(引数1, 引数2, ...) => {/*関数の処理*/}

// アロー関数を変数に代入した形
let arrowFunction = (引数1, 引数2, ...) => {/*関数の処理*/}
```
**_アロー関数_**は無名関数に近い書き方になっています。実際、**_アロー関数_**は無名関数の記法を簡略化するために考案されたものです。
引数がある場合は()の中に`(引数1, 引数2, ...) `のようにカンマを使って並べていきます。これは他の関数の定義のやり方と同様です。
引数を持たない場合はその記述を省略することができます。

もし関数の引数が一つだけであれば引数の()を省略できます。
```js
let arrowFunc = x => {console.log(x);}
```
ただし引数がない場合は()そのものを省略することはできません。
```js
// 引数を持たないアロー関数
let arrowFunc = () => console.log('this is an arrow function');
```
もし**_アロー関数_**の処理文が戻り値`return`を使った文一行のみであれば、この`return`を省略して記述することができます。この省略記法は見た目も簡潔で頻繁に使われますので覚えておきましょう。
```js
let arrowFunc1 = (a, b) => { return a*b; };

// 上記のアロー関数は次と同じ
let arrowFunc2 = (a, b) => a * b;
```


ただし戻り値がオブジェクトの場合は、関数ブロックの「{}」でないことを明示するために「()」で囲む決まりになっています。
```js
// オブジェクトを返すアロー関数
let arrowFunc2 = (x, y) => ({
  name:x,
  color:y
});
```

## アロー関数の特徴

**_アロー関数_**は旧来の関数の定義の記述を簡潔に書くために導入されたものなのですが、必ずしも他の方法で定義された関数と同じ挙動をする訳ではないので注意が必要です。以下で**_アロー関数_**の特徴について触れていきます。

### アロー関数とコンストラクタ

**_アロー関数_**は**コンストラクタ**として振舞うことができません。**コンストラクタ**というのは関数を使って定義された一種のオブジェクトです。**コンストラクタ**は予約語`new`を使って、雛形として定義されたオブジェクトをその都度生成することができます。

```js
// コンストラクタの定義
let Fruit = function (name, color) {
  //  引数をプロパティに格納
  this.name = name;
  this.color = color;
};
// コンストラクタを生成
let myFruit = new Fruit('apple','red');

console.log(myFruit.color); // red
```
**_アロー関数_**で同様のことをしようとするとエラーになります。
```js
let Fruit = (name, color) => {
  this.name = name;
  this.color = color;
};
let myFruit = new Fruit('apple', 'red'); // エラーになる
```

### アロー関数は配列argumentsを持たない

**_アロー関数_**は引数を格納した配列argumentsを持つことができないので使用するとエラーとなります。

```js
// 無名関数
let func = function(){
  for(let i = 0; i < arguments.length; ++i){
    console.log(arguments[i]); // 配列要素が出力される
  }
};

func('a','b','c','d','e');

// アロー関数
let func = () => {
  for(let i = 0; i < arguments.length; ++i){
    console.log(arguments[i]); // エラー
  }
};

func('a','b','c','d','e');
```

### アロー関数とthis
**_アロー関数_**を使う際に注意しないといけないのが、通常の関数と**_アロー関数_**では`this`の扱いが異なる点です。
レッスン8でもすでに触れたように、通常の関数ではthisの意味は使われるスコープや状況によって変化しますが、**_アロー関数_**を使った場合のthisは、**_アロー関数_**の定義時に定められた対象のまま変わることがありません。このような**_アロー関数_**の性質を**「thisをレキシカルに束縛する」**とも表現したりします。下記の例では、オブジェクトのプロパティとして設定したメソッドとして呼び出した場合は、そのthisは呼び出し元のオブジェクトを指しています。しかし関数呼び出しした際のthisはグローバルオブジェクトを指します。

```js
// 関数定義のthis - 無名関数定義の場合
let name = 'Everyone';
let obj1 = {
  name: 'Michael',
  sayHello: function(){
    console.log(`Hello, ${this.name}!`);
    let sayHello = function(){
    console.log(`Hello, ${this.name}!`);
    }
    sayHello(); // 2.関数呼び出し： 'Hello, Everyone!'
  }
}
obj1.sayHello(); // 1.メソッド呼び出し : 'Hello, Michael!'
```

無名関数を使う代わりに**_アロー関数_**で置き換えて定義すると、関数呼び出しした際のthisであっても定義元のオブジェクトを指します。

```js
// アロー関数定義のthis
let name = 'Everyone';
let obj1 = {
  name: 'Michael',
  sayHello: function() {
    console.log(`Hello, ${this.name}!`);
    // アロー関数で定義
    let sayHello = () => {
      console.log(`Hello, ${this.name}!`);
    }
    sayHello(); // 関数呼び出し： 'Hello, Michael!'
  }
}
obj1.sayHello(); //メソッド呼び出し : 'Hello, Michael!'
```

ES5以前は、thisの指す内容が状況によって変わるのを回避して束縛しておくために**bindメソッド**や**that(self)を使ったthisの退避**などを駆使していましたが**_アロー関数_**によりその必要がなくなりました。

- [参考：アロー関数 - MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions)


## コールバック関数

ある関数の引数として渡され、その関数の中で実行される関数のことを**_コールバック関数_**と言います。
以下の例では関数呼び出し時に無名関数を定義して引数として渡しています。関数funcの処理文の中で仮引数`callback`が**_コールバック関数_**として実行されています。

```js
function func(callback) {
  callback();  // コールバック関数の実行
  console.log('Second!');
}

// 関数呼び出し時に引数に関数を渡す
func(function() {console.log('First!');});
```

出力結果:
```js
'First!'
'Second!'
```

このように**_コールバック関数_**として定義される関数は、関数呼び出し時の実引数としてそのまま定義されることがよくあります。特に簡潔な記述が特徴である**_アロー関数_**はこのような使われ方に向いているのでよく利用されます。

## コールバック関数を使ったタイマー処理

例えばブラウザ上でスライドーショーを実装させたい場合、一定間隔で処理を行うための仕組みが必要になります。JavaScriptにはタイマー処理を行うための関数`setTimeout`と`setInterval`が用意されています。これらの関数に**_コールバック関数_**を引数として渡すことで、タイマー制御された処理を簡単に実装することができます。

### setTimeout

`setTimeout(コールバック関数、時間(ミリ秒))`の構文を持つ`setTimeout`は、引数として指定した時間が経過した時に、ある特定の処理を1回だけ行う場合に使います。この特定の処理は**_コールバック関数_**として引数で渡すことができます。

### setInterval

`setInterval(コールバック関数、時間(ミリ秒))`の構文を持つは`setInterval`は、一定時間ごとにある特定の処理を繰り返す場合に使います。`setTimeout`同様、この特定の処理は**_コールバック関数_**として引数で渡すことができます。

例えば以下のコードを実行すると1秒ごとにログが表示されます。
```js
setInterval(function() { console.log('Hello'); }, 1000);
```

## クロージャー

関数の中に関数が存在する場合を考えます。この時内部の関数からは、外側の関数で定義された変数に対し直接参照先にアクセスできます。**_クロージャー(closure)_**はこのように内外2つの関数を使い、内側の関数が外側の関数のローカル変数を参照する仕組みを使った特殊なオブジェクトです。
説明だけではイメージが湧きにくいので実際に**_クロージャー_**の例を見てみましょう。

```js
function externalFunction() {
  let planet = 'The Sun'; // アクセスされるローカル変数
  return function innerFunction() {
    console.log(planet); // 内部関数から外部のローカル変数にアクセス
  };
};
let closure = externalFunction(); // グローバル変数

closure(); // 'The Sun'
```

上記の例では関数`innerFunction`が、自身を内包している`externalFunction`のローカル変数`planet`を参照しています。もちろんこのローカル変数はプライベートな関数スコープを持つので外部からアクセスすることはできません。

そして`externalFunction`がグローバル変数`closure`に格納されることで、これが**_クロージャー_**としてはたらきます。
**_クロージャー_**となっているこの変数`closure`を実行すると、戻り値として関数`innerFunction`が返りますが、この時参照された`planet`はその値が破棄されることなく保持され続けます。通常の関数内で定義されたローカル変数が、関数が呼ばれるたびに生成されるのとは対照的であり、これが**_クロージャー_**の最も重要な特徴です。


### クロージャーの利用例

**_クロージャー(closure)_**の特徴は、すでに述べたようにクロージャー外からアクセスできない変数に、内部の関数が参照できそれを保持することができるということです。よくあげられるクロージャーの実用例として、**「値を呼び出すたびに数をカウントしてくれる関数」**があります。
まず次のようなクロージャーでない関数を呼び出した場合、呼び出すごとにローカル変数の値が新たに生成されるためカウントされることはありません。

```js
// クロージャーでない場合
function func() {
  let counter = 1;
  counter++;
  console.log(counter);
}

// カウントされない
func(); // 1
func(); // 1
func(); // 1
```

一方で**_クロージャー_**は内部関数で参照した変数の値が保持されるため呼び出すたびに数がカウントされます。

```js
// クロージャーの場合
function func(){
  let counter = 1;
  return function(){
    console.log(counter);
    counter++
  };
}
let closure = func();

// カウントされる
closure(); // 1
closure(); // 2
closure(); // 3
```

また次のように複数のグローバルオブジェクトに格納した場合、それぞれが独立したコンテキストをもつようになります。

```js
function func() {
  let counter = 1;
  return function() {
    console.log(counter);
    counter++
  };
}
let closure1 = func();

closure1(); // 1
closure1(); // 2
closure1(); // 3

let closure2 = func();

// closure1とは独立してカウントされる
closure2(); // 1
closure2(); // 2
closure2(); // 3
```

ただし、実は「数をカウントしてくれる関数」自体は次のようにグローバル変数を使うことでも実装できます。
```js
var counter = 1; // グローバル変数

function func() {
  console.log(counter)
  return counter++;
}
func(); // 1
func(); // 2
func(); // 3
```
グローバル変数を使う場合と比較して**_クロージャー_**を使う利点をあげるとすれば、その名の通り外部から変数にアクセスできない仕組みになっていることが挙げられます。このような仕組みは特にオブジェクト指向型のプログラミングでは**カプセル化**と言われ、コードの安全性を高める上で重要なテクニックとなっています。どこからでもアクセスできるグローバル変数をむやみに増やしすぎるのは、意図しない変数の改変の危険性を考えるとあまり良いことではありません。
**_クロージャー_**のテクニックうまく利用することでより安全で保守性の高いプログラムにすることができるのです。

## 再帰関数

**_再帰関数_**はその関数の命令文の中で自分自身を呼び出している関数のことです。
再帰関数の具体例としてよく使われるのが**_階乗(factorial)_**の計算です。
階乗の計算は例えば`6!`であれば、

```
6 * 5 * 4 * 3 * 2 * 1 = 720
```
のように指定した数から1を引いた数を、その数が1になるまで繰り返し掛け合わせていきます。
これを再帰関数で表現すると次のようになります。
```js
let factorial = (n) => {
  // nの値によって条件分岐
  if(n===1){
    return 1; // 1なら1を戻り値として終了
  }else{
    return n*factorial(n - 1); // (n - 1)の引数で自身の関数を呼ぶ
  }
}

console.log(factorial(6)); // 720
```

上の例では**_アロー関数_**を使っていますがその他の定義方法でももちろん問題ありません。
この関数は戻り値の計算`n*factorial(n-1)`で自分自身が呼ばれ、これは`n`の値が1になるまで繰り返し行われます。
再帰関数は、**while文**と同様に**無限ループに注意**しなければなりません。意図せず無限回の処理を実行してPCに負荷を与えてしまわないよう、呼び出しを終了する条件を記述するなど注意する必要があります。


## チャレンジ

- [チャレンジ9](./challenge/README.md)

## 更に学ぼう

- [JavaScript入門 - ドットインストール](https://dotinstall.com/lessons/basic_javascript_v2)

### 本で学ぶ

- [Eloquent JavaScript 3rd Edition](http://eloquentjavascript.net/)
